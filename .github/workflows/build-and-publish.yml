name: Build and Publish Registry

on:
  push:
    branches:
      - main
    paths:
      - 'appliances/**'
      - 'appliances.yaml'
      - 'bin/build-appliance.sh'
      - '.github/workflows/build-and-publish.yml'
      - '.base-image-fingerprint'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all appliances'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pages: write
  id-token: write
  security-events: write

jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      appliances: ${{ steps.set-matrix.outputs.appliances }}
      versions: ${{ steps.set-matrix.outputs.versions }}
      has_builds: ${{ steps.set-matrix.outputs.has_builds }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to detect changes

      - name: Install yq
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          command: |
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

      - name: Detect changed appliances
        id: changes
        run: |
          # For workflow_dispatch with force_rebuild, build all appliances
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ inputs.force_rebuild }}" = "true" ]; then
              echo "Force rebuild requested - building all appliances"
              CHANGED_APPLIANCES=$(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml | tr '\n' ' ')
            else
              echo "Workflow dispatch without force - no builds"
              CHANGED_APPLIANCES=""
            fi
          else
            # Get list of changed files
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            echo "Changed files:"
            echo "$CHANGED_FILES"

            CHANGED_APPLIANCES=""
            REBUILD_ALL=false

            # Check for changes that require rebuilding ALL appliances
            # - build-appliance.sh affects how images are built
            # - build-and-publish.yml workflow changes
            # - .base-image-fingerprint means base image was updated
            if echo "$CHANGED_FILES" | grep -qE '^(bin/build-appliance\.sh|\.github/workflows/build-and-publish\.yml|\.base-image-fingerprint)$'; then
              echo "Core build files changed - rebuilding all appliances"
              REBUILD_ALL=true
            fi

            # Check for appliances.yaml changes
            if echo "$CHANGED_FILES" | grep -q '^appliances\.yaml$'; then
              echo "appliances.yaml changed - analyzing changes..."

              # Get the previous version of appliances.yaml
              git show HEAD~1:appliances.yaml > /tmp/appliances.yaml.old 2>/dev/null || echo "" > /tmp/appliances.yaml.old

              # Get list of appliances in old and new versions
              OLD_APPLIANCES=$(yq -r '.appliances[] | select(.enabled != false) | .name' /tmp/appliances.yaml.old 2>/dev/null | sort || echo "")
              NEW_APPLIANCES=$(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml | sort)

              # Find newly added appliances
              ADDED_APPLIANCES=$(comm -13 <(echo "$OLD_APPLIANCES") <(echo "$NEW_APPLIANCES") | tr '\n' ' ')
              if [ -n "$ADDED_APPLIANCES" ]; then
                echo "New appliances added: $ADDED_APPLIANCES"
                CHANGED_APPLIANCES="${CHANGED_APPLIANCES}${ADDED_APPLIANCES}"
              fi

              # Check if defaults section changed (affects all appliances)
              OLD_DEFAULTS=$(yq -o=json '.defaults' /tmp/appliances.yaml.old 2>/dev/null || echo "{}")
              NEW_DEFAULTS=$(yq -o=json '.defaults' appliances.yaml)
              if [ "$OLD_DEFAULTS" != "$NEW_DEFAULTS" ]; then
                echo "Defaults changed - rebuilding all appliances"
                REBUILD_ALL=true
              fi

              # Check if any existing appliance's config changed (e.g., architectures)
              for appliance in $NEW_APPLIANCES; do
                OLD_CONFIG=$(yq -o=json ".appliances[] | select(.name == \"$appliance\")" /tmp/appliances.yaml.old 2>/dev/null || echo "{}")
                NEW_CONFIG=$(yq -o=json ".appliances[] | select(.name == \"$appliance\")" appliances.yaml)
                if [ "$OLD_CONFIG" != "$NEW_CONFIG" ] && [ -n "$OLD_CONFIG" ] && [ "$OLD_CONFIG" != "{}" ]; then
                  echo "Config changed for $appliance"
                  CHANGED_APPLIANCES="${CHANGED_APPLIANCES}${appliance} "
                fi
              done

              rm -f /tmp/appliances.yaml.old
            fi

            # If rebuild all flag is set, get all appliances
            if [ "$REBUILD_ALL" = "true" ]; then
              CHANGED_APPLIANCES=$(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml | tr '\n' ' ')
            else
              # Detect which individual appliance directories changed
              for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
                if echo "$CHANGED_FILES" | grep -q "^appliances/${appliance}/"; then
                  # Don't add duplicates
                  if ! echo "$CHANGED_APPLIANCES" | grep -qw "$appliance"; then
                    CHANGED_APPLIANCES="${CHANGED_APPLIANCES}${appliance} "
                  fi
                fi
              done
            fi
          fi

          # Trim whitespace
          CHANGED_APPLIANCES=$(echo "$CHANGED_APPLIANCES" | xargs)
          echo "Changed appliances: $CHANGED_APPLIANCES"
          echo "changed_appliances=$CHANGED_APPLIANCES" >> $GITHUB_OUTPUT

      - name: Generate build matrix
        id: set-matrix
        run: |
          CHANGED_APPLIANCES="${{ steps.changes.outputs.changed_appliances }}"

          # Read defaults from appliances.yaml
          DEFAULT_ARCHS=$(yq -o=json '.defaults.architectures // ["amd64"]' appliances.yaml)

          # Generate matrix only for changed appliances
          if [ -z "$CHANGED_APPLIANCES" ]; then
            echo "No appliances to build"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "has_builds=false" >> $GITHUB_OUTPUT
          else
            MATRIX_INCLUDES=$(for appliance in $CHANGED_APPLIANCES; do
              # Read version from appliance.yaml, default to 0.0.0
              version=$(yq -r '.version // "0.0.0"' "appliances/${appliance}/appliance.yaml" 2>/dev/null || echo "0.0.0")
              # Use appliance-specific architectures if defined, otherwise use defaults
              archs=$(yq -o=json ".appliances[] | select(.name == \"${appliance}\") | .architectures" appliances.yaml)
              if [ "$archs" = "null" ] || [ -z "$archs" ]; then
                archs="$DEFAULT_ARCHS"
              fi
              echo "{\"appliance\": \"${appliance}\", \"version\": \"${version}\", \"archs\": ${archs}}"
            done | jq -s '[.[] | .archs[] as $arch | {appliance: .appliance, version: .version, arch: $arch}]')

            MATRIX=$(echo "$MATRIX_INCLUDES" | jq -c '{include: .}')
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "has_builds=true" >> $GITHUB_OUTPUT
          fi

          # Output all appliance names for other jobs (not just changed ones)
          APPLIANCES=$(yq -o=json '[.appliances[] | select(.enabled != false) | .name]' appliances.yaml | jq -c '.')
          echo "appliances=$APPLIANCES" >> $GITHUB_OUTPUT

          # Output appliance versions for release job
          VERSIONS=$(for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
            version=$(yq -r '.version // "0.0.0"' "appliances/${appliance}/appliance.yaml" 2>/dev/null || echo "0.0.0")
            echo "{\"name\": \"${appliance}\", \"version\": \"${version}\"}"
          done | jq -s -c '.')
          echo "versions=$VERSIONS" >> $GITHUB_OUTPUT

          # Debug output
          echo "Changed appliances: $CHANGED_APPLIANCES"
          echo "Generated matrix:"
          echo "$MATRIX" | jq . || echo "(empty)"
          echo "All appliances: $APPLIANCES"
          echo "Versions: $VERSIONS"

  build:
    needs: generate-matrix
    if: needs.generate-matrix.outputs.has_builds == 'true'
    runs-on: self-hosted
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
      fail-fast: false

    steps:
      - name: Clean workspace
        run: |
          # Clean up root-owned files from previous builds
          sudo rm -rf ${{ github.workspace }}/.build || true
          sudo rm -rf ${{ github.workspace }}/.cache || true
          sudo rm -rf ${{ github.workspace }}/registry || true

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Incus tools
        uses: ./.github/actions/setup-incus-tools

      - name: Build appliance with Incus
        run: ./bin/build-appliance.sh ${{ matrix.appliance }} ${{ matrix.arch }}
        timeout-minutes: 15

      - name: Extract rootfs for security scanning
        id: extract
        run: |
          BUILD_DIR=".build/${{ matrix.appliance }}/${{ matrix.arch }}"
          SCAN_DIR="${BUILD_DIR}/rootfs-scan"
          mkdir -p "${SCAN_DIR}"

          # Extract squashfs for scanning
          sudo unsquashfs -d "${SCAN_DIR}/rootfs" "${BUILD_DIR}/rootfs.squashfs"
          sudo chown -R $(id -u):$(id -g) "${SCAN_DIR}"

          echo "scan_dir=${SCAN_DIR}/rootfs" >> $GITHUB_OUTPUT

      - name: Scan rootfs for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'rootfs'
          scan-ref: ${{ steps.extract.outputs.scan_dir }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          ignore-unfixed: true
          trivyignores: '.trivyignore'

      - name: Install Trivy CLI
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          command: |
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin

      - name: Fail on critical vulnerabilities
        run: |
          # Check for critical vulnerabilities - fail the build if found
          trivy rootfs --exit-code 1 --severity CRITICAL --ignore-unfixed --ignorefile .trivyignore ${{ steps.extract.outputs.scan_dir }} || {
            echo "::error::Critical vulnerabilities found in ${{ matrix.appliance }} (${{ matrix.arch }})"
            exit 1
          }

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: '${{ matrix.appliance }}-${{ matrix.arch }}'

      - name: Cleanup scan directory
        if: always()
        run: |
          BUILD_DIR=".build/${{ matrix.appliance }}/${{ matrix.arch }}"
          sudo rm -rf "${BUILD_DIR}/rootfs-scan"

      - name: Prepare image files for release
        id: metadata
        run: |
          # Files are in .build/<appliance>/<arch>/
          BUILD_DIR=".build/${{ matrix.appliance }}/${{ matrix.arch }}"

          # Verify files exist
          if [ ! -f "${BUILD_DIR}/incus.tar.xz" ] || [ ! -f "${BUILD_DIR}/rootfs.squashfs" ]; then
            echo "Error: Build files not found in ${BUILD_DIR}"
            ls -la "${BUILD_DIR}" || true
            exit 1
          fi

          # Rename files to include appliance and arch for uniqueness in release
          METADATA_NAME="${{ matrix.appliance }}-${{ matrix.arch }}-incus.tar.xz"
          ROOTFS_NAME="${{ matrix.appliance }}-${{ matrix.arch }}-rootfs.squashfs"

          cp "${BUILD_DIR}/incus.tar.xz" "${BUILD_DIR}/${METADATA_NAME}"
          cp "${BUILD_DIR}/rootfs.squashfs" "${BUILD_DIR}/${ROOTFS_NAME}"

          echo "metadata_name=${METADATA_NAME}" >> $GITHUB_OUTPUT
          echo "rootfs_name=${ROOTFS_NAME}" >> $GITHUB_OUTPUT
          echo "build_dir=${BUILD_DIR}" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: images-${{ matrix.appliance }}-${{ matrix.arch }}
          path: |
            ${{ steps.metadata.outputs.build_dir }}/${{ steps.metadata.outputs.metadata_name }}
            ${{ steps.metadata.outputs.build_dir }}/${{ steps.metadata.outputs.rootfs_name }}
          retention-days: 1

      - name: Upload registry artifact
        uses: actions/upload-artifact@v4
        with:
          name: registry-${{ matrix.appliance }}-${{ matrix.arch }}
          path: registry/
          retention-days: 1

  release:
    needs: [generate-matrix, build]
    if: needs.generate-matrix.outputs.has_builds == 'true'
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Install yq
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          command: |
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

      - name: Download all image artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: images-*
          path: release-files/
          merge-multiple: true

      - name: List downloaded files
        run: |
          echo "==> Downloaded files for release:"
          ls -lh release-files/

      - name: Generate release information
        id: release-info
        run: |
          # Get versions from the matrix output
          VERSIONS='${{ needs.generate-matrix.outputs.versions }}'

          # Generate markdown list of appliances with versions
          LIST=""
          for row in $(echo "$VERSIONS" | jq -r '.[] | @base64'); do
            name=$(echo "$row" | base64 -d | jq -r '.name')
            version=$(echo "$row" | base64 -d | jq -r '.version')
            archs=$(yq -r ".appliances[] | select(.name == \"${name}\") | .architectures // [\"amd64\", \"arm64\"] | join(\", \")" appliances.yaml)
            LIST="${LIST}- **${name}** v${version} (${archs})"$'\n'
          done

          # Calculate a combined release tag based on date
          RELEASE_DATE=$(date +%Y%m%d)
          RELEASE_TAG="v${RELEASE_DATE}"

          echo "list<<EOF" >> $GITHUB_OUTPUT
          echo "$LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "release_date=${RELEASE_DATE}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Get the previous release tag
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            echo "Generating changelog since ${PREV_TAG}"
            CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges 2>/dev/null || echo "- Initial release")
          else
            echo "No previous tag found, showing recent commits"
            CHANGELOG=$(git log -10 --pretty=format:"- %s (%h)" --no-merges 2>/dev/null || echo "- Initial release")
          fi

          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create/Update Latest Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: "Latest Appliance Images"
          draft: false
          prerelease: false
          make_latest: true
          files: release-files/*
          body: |
            ## Latest Appliance Images

            This release contains the latest built appliance images.

            **Last updated:** ${{ github.event.head_commit.timestamp }}

            ### Usage

            Add the remote:
            ```bash
            incus remote add appliance https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }} --protocol simplestreams
            ```

            Launch an appliance (supports version tags):
            ```bash
            # Latest version
            incus launch appliance:nginx my-nginx

            # Specific version
            incus launch appliance:nginx:1.0.0 my-nginx

            # Latest in major version
            incus launch appliance:nginx:1 my-nginx
            ```

            ### Available Appliances

            ${{ steps.release-info.outputs.list }}

            ### Changes

            ${{ steps.changelog.outputs.changelog }}

      - name: Create Versioned Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release-info.outputs.release_tag }}
          name: "Release ${{ steps.release-info.outputs.release_tag }}"
          draft: false
          prerelease: false
          make_latest: false
          files: release-files/*
          body: |
            ## Appliance Images - ${{ steps.release-info.outputs.release_tag }}

            **Built:** ${{ github.event.head_commit.timestamp }}

            ### Appliances

            ${{ steps.release-info.outputs.list }}

            ### Changes

            ${{ steps.changelog.outputs.changelog }}

  publish:
    needs: [generate-matrix, build]
    if: needs.generate-matrix.outputs.has_builds == 'true'
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          command: |
            sudo apt-get update && sudo apt-get install -y jq
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

      - name: Download existing registry from GitHub Pages
        run: |
          REGISTRY_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          mkdir -p existing-registry/streams/v1
          mkdir -p existing-registry/images

          # Try to fetch existing images.json (may not exist on first run)
          EMPTY_REGISTRY='{"content_id": "images", "datatype": "image-downloads", "format": "products:1.0", "products": {}}'

          if curl -sf "${REGISTRY_URL}/streams/v1/images.json" -o existing-registry/streams/v1/images.json; then
            # Verify it's valid JSON
            if jq empty existing-registry/streams/v1/images.json 2>/dev/null; then
              echo "Downloaded existing images.json"
              jq '.products | keys' existing-registry/streams/v1/images.json
            else
              echo "Downloaded file is not valid JSON - starting fresh"
              echo "$EMPTY_REGISTRY" > existing-registry/streams/v1/images.json
            fi
          else
            echo "No existing registry found - starting fresh"
            echo "$EMPTY_REGISTRY" > existing-registry/streams/v1/images.json
          fi

      - name: Download all registry artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: registry-*
          path: registries/

      - name: Merge registries
        run: |
          mkdir -p merged-registry/streams/v1
          mkdir -p merged-registry/images

          # List what we downloaded
          echo "==> Downloaded artifacts:"
          ls -la registries/

          # Start with existing registry (preserves unchanged appliances)
          echo "==> Starting with existing registry:"
          cp existing-registry/streams/v1/images.json merged-registry/streams/v1/images.json
          jq '.products | keys' merged-registry/streams/v1/images.json

          # Merge all registry artifacts
          for reg_dir in registries/registry-*; do
            echo "==> Processing $reg_dir"
            ls -la "$reg_dir" || true

            # Find the images.json file
            IMAGES_JSON=""
            if [ -f "$reg_dir/registry/streams/v1/images.json" ]; then
              IMAGES_JSON="$reg_dir/registry/streams/v1/images.json"
            elif [ -f "$reg_dir/streams/v1/images.json" ]; then
              IMAGES_JSON="$reg_dir/streams/v1/images.json"
            fi

            if [ -n "$IMAGES_JSON" ] && [ -f "$IMAGES_JSON" ]; then
              echo "  Merging images.json from $IMAGES_JSON"
              # Merge products from this images.json into the merged one
              jq -s '.[0].products * .[1].products | {content_id: "images", datatype: "image-downloads", format: "products:1.0", products: .}' \
                merged-registry/streams/v1/images.json "$IMAGES_JSON" > merged-registry/streams/v1/images.json.tmp
              mv merged-registry/streams/v1/images.json.tmp merged-registry/streams/v1/images.json
            fi

            # Copy image files
            if [ -d "$reg_dir/registry/images" ]; then
              cp -r "$reg_dir/registry/images"/* merged-registry/images/ 2>/dev/null || true
            elif [ -d "$reg_dir/images" ]; then
              cp -r "$reg_dir/images"/* merged-registry/images/ 2>/dev/null || true
            fi
          done

          # Generate index.json with products array (required by Incus simplestreams client)
          # The products array must list all product keys from images.json
          PRODUCTS_ARRAY=$(jq -c '.products | keys' merged-registry/streams/v1/images.json)
          cat > merged-registry/streams/v1/index.json <<INDEXEOF
          {
            "index": {
              "images": {
                "datatype": "image-downloads",
                "path": "streams/v1/images.json",
                "format": "products:1.0",
                "products": ${PRODUCTS_ARRAY}
              }
            },
            "format": "index:1.0"
          }
          INDEXEOF

          echo "==> Merged registry contents:"
          find merged-registry -type f
          echo "==> Products in images.json:"
          jq '.products | keys' merged-registry/streams/v1/images.json
          echo "==> Index.json:"
          cat merged-registry/streams/v1/index.json

      - name: Generate index.html and directory listings
        run: |
          REGISTRY_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Generate appliance list HTML with links to detail pages
          APPLIANCE_HTML=""
          for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
            version=$(yq -r '.version // "0.0.0"' "appliances/${appliance}/appliance.yaml" 2>/dev/null || echo "0.0.0")
            description=$(yq -r ".appliances[] | select(.name == \"${appliance}\") | .description // \"Appliance\"" appliances.yaml)
            archs=$(yq -r ".appliances[] | select(.name == \"${appliance}\") | .architectures // [\"amd64\", \"arm64\"] | join(\", \")" appliances.yaml)
            APPLIANCE_HTML="${APPLIANCE_HTML}<li><a href=\"images/${appliance}/\"><strong>${appliance}</strong></a> v${version} - ${description} (${archs})</li>"
          done

          # Generate main index.html
          cat > merged-registry/index.html <<'MAINEOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>Incus Appliance Registry</title>
            <style>
              body { font-family: monospace; max-width: 900px; margin: 20px auto; padding: 0 20px; }
              h1 { border-bottom: 1px solid #ccc; padding-bottom: 10px; }
              table { border-collapse: collapse; width: 100%; }
              th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }
              th { background: #f5f5f5; }
              a { color: #0066cc; text-decoration: none; }
              a:hover { text-decoration: underline; }
              pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
              code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
              .date { color: #666; font-size: 0.9em; }
              li { margin: 8px 0; }
            </style>
          </head>
          <body>
            <h1>Incus Appliance Registry</h1>
            <p>SimpleStreams image server for pre-configured Incus system containers.</p>

            <h2>Quick Start</h2>
          MAINEOF

          echo "    <pre><code>incus remote add appliance ${REGISTRY_URL} --protocol simplestreams" >> merged-registry/index.html
          echo "incus launch appliance:nginx my-nginx</code></pre>" >> merged-registry/index.html

          cat >> merged-registry/index.html <<MAINEOF2

            <h2>Available Appliances</h2>
            <ul>
          ${APPLIANCE_HTML}
            </ul>

            <h2>Browse</h2>
            <p><a href="images/">Browse all images</a> | <a href="streams/v1/images.json">images.json</a></p>

            <h2>Documentation</h2>
            <p>See the <a href="https://github.com/${{ github.repository }}">GitHub repository</a> for full documentation.</p>

            <p class="date">Last updated: ${BUILD_DATE}</p>
          </body>
          </html>
          MAINEOF2

          # Generate per-appliance directory listings
          # Read file paths from images.json for accurate listings
          IMAGES_JSON="merged-registry/streams/v1/images.json"

          for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
            version=$(yq -r '.version // "0.0.0"' "appliances/${appliance}/appliance.yaml" 2>/dev/null || echo "0.0.0")
            archs=$(yq -r ".appliances[] | select(.name == \"${appliance}\") | .architectures // [\"amd64\", \"arm64\"] | .[]" appliances.yaml)

            # Create appliance directory structure
            mkdir -p "merged-registry/images/${appliance}"

            # Generate architecture list for appliance
            ARCH_ROWS=""
            for arch in $archs; do
              mkdir -p "merged-registry/images/${appliance}/${arch}"
              ARCH_ROWS="${ARCH_ROWS}<tr><td><a href=\"${arch}/\">${arch}/</a></td><td>-</td><td>${BUILD_DATE}</td></tr>"

              # Find files for this appliance/arch from images.json
              # Look for products that have the appliance alias with this arch
              FILE_ROWS=""

              # Get all products that have this appliance alias for this arch
              for product_key in $(jq -r '.products | keys[]' "$IMAGES_JSON"); do
                product_arch=$(jq -r ".products[\"$product_key\"].arch" "$IMAGES_JSON")
                product_aliases=$(jq -r ".products[\"$product_key\"].aliases // \"\"" "$IMAGES_JSON")

                # Check if this product matches our appliance and arch
                if [[ "$product_arch" == "$arch" ]] && echo "$product_aliases" | grep -qE "(^|,)${appliance}(,|\$|/)"; then
                  # Get the latest version
                  latest_version=$(jq -r ".products[\"$product_key\"].versions | keys | sort | last" "$IMAGES_JSON")

                  # Get file paths and sizes from items
                  for item_key in $(jq -r ".products[\"$product_key\"].versions[\"$latest_version\"].items | keys[]" "$IMAGES_JSON"); do
                    item_path=$(jq -r ".products[\"$product_key\"].versions[\"$latest_version\"].items[\"$item_key\"].path" "$IMAGES_JSON")
                    item_size=$(jq -r ".products[\"$product_key\"].versions[\"$latest_version\"].items[\"$item_key\"].size" "$IMAGES_JSON")

                    if [[ -n "$item_path" ]] && [[ "$item_path" != "null" ]]; then
                      filename=$(basename "$item_path")
                      # Convert size to human readable
                      if [[ "$item_size" -gt 1073741824 ]]; then
                        human_size="$(echo "scale=1; $item_size/1073741824" | bc)G"
                      elif [[ "$item_size" -gt 1048576 ]]; then
                        human_size="$(echo "scale=1; $item_size/1048576" | bc)M"
                      elif [[ "$item_size" -gt 1024 ]]; then
                        human_size="$(echo "scale=1; $item_size/1024" | bc)K"
                      else
                        human_size="${item_size}B"
                      fi
                      FILE_ROWS="${FILE_ROWS}<tr><td><a href=\"../../${item_path#images/}\">${filename}</a></td><td>${human_size}</td><td>${BUILD_DATE}</td></tr>"
                    fi
                  done
                fi
              done

              if [ -z "$FILE_ROWS" ]; then
                FILE_ROWS="<tr><td colspan=\"3\"><em>No image files found for this architecture</em></td></tr>"
              fi

              # Generate per-architecture page
              cat > "merged-registry/images/${appliance}/${arch}/index.html" <<ARCHEOF
          <!DOCTYPE html>
          <html>
          <head>
            <title>Index of /images/${appliance}/${arch}/</title>
            <style>
              body { font-family: monospace; max-width: 900px; margin: 20px auto; padding: 0 20px; }
              h1 { border-bottom: 1px solid #ccc; padding-bottom: 10px; }
              table { border-collapse: collapse; width: 100%; }
              th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }
              th { background: #f5f5f5; }
              a { color: #0066cc; text-decoration: none; }
              a:hover { text-decoration: underline; }
              pre { background: #f4f4f4; padding: 15px; border-radius: 5px; }
              .info { margin-bottom: 20px; }
            </style>
          </head>
          <body>
            <h1>Index of /images/${appliance}/${arch}/</h1>
            <p class="info"><strong>Appliance:</strong> ${appliance} | <strong>Architecture:</strong> ${arch} | <strong>Version:</strong> ${version}</p>
            <table>
              <tr><th>Name</th><th>Size</th><th>Last Modified</th></tr>
              <tr><td><a href="../">../</a></td><td>-</td><td>-</td></tr>
          ${FILE_ROWS}
            </table>
            <h3>Launch</h3>
            <pre>incus launch appliance:${appliance} my-${appliance}</pre>
          </body>
          </html>
          ARCHEOF
            done

            # Generate appliance index page
            cat > "merged-registry/images/${appliance}/index.html" <<APPEOF
          <!DOCTYPE html>
          <html>
          <head>
            <title>Index of /images/${appliance}/</title>
            <style>
              body { font-family: monospace; max-width: 900px; margin: 20px auto; padding: 0 20px; }
              h1 { border-bottom: 1px solid #ccc; padding-bottom: 10px; }
              table { border-collapse: collapse; width: 100%; }
              th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }
              th { background: #f5f5f5; }
              a { color: #0066cc; text-decoration: none; }
              a:hover { text-decoration: underline; }
              pre { background: #f4f4f4; padding: 15px; border-radius: 5px; }
              .info { margin-bottom: 20px; }
            </style>
          </head>
          <body>
            <h1>Index of /images/${appliance}/</h1>
            <p class="info"><strong>Version:</strong> ${version}</p>
            <table>
              <tr><th>Name</th><th>Size</th><th>Last Modified</th></tr>
              <tr><td><a href="../">../</a></td><td>-</td><td>-</td></tr>
          ${ARCH_ROWS}
            </table>
            <h3>Launch</h3>
            <pre>incus launch appliance:${appliance} my-${appliance}</pre>
          </body>
          </html>
          APPEOF
          done

          # Generate /images/ index page
          IMAGES_LIST=""
          for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
            IMAGES_LIST="${IMAGES_LIST}<tr><td><a href=\"${appliance}/\">${appliance}/</a></td><td>-</td><td>${BUILD_DATE}</td></tr>"
          done

          cat > "merged-registry/images/index.html" <<IMAGESEOF
          <!DOCTYPE html>
          <html>
          <head>
            <title>Index of /images/</title>
            <style>
              body { font-family: monospace; max-width: 900px; margin: 20px auto; padding: 0 20px; }
              h1 { border-bottom: 1px solid #ccc; padding-bottom: 10px; }
              table { border-collapse: collapse; width: 100%; }
              th, td { text-align: left; padding: 8px 12px; border-bottom: 1px solid #eee; }
              th { background: #f5f5f5; }
              a { color: #0066cc; text-decoration: none; }
              a:hover { text-decoration: underline; }
            </style>
          </head>
          <body>
            <h1>Index of /images/</h1>
            <table>
              <tr><th>Name</th><th>Size</th><th>Last Modified</th></tr>
              <tr><td><a href="../">../</a></td><td>-</td><td>-</td></tr>
          ${IMAGES_LIST}
            </table>
          </body>
          </html>
          IMAGESEOF

          echo "==> Generated directory listings:"
          find merged-registry -name "index.html" -type f

      - name: List final registry contents
        run: |
          echo "==> Final registry structure:"
          find merged-registry -type f

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: merged-registry/

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  summary:
    needs: [generate-matrix, release, publish]
    runs-on: ubuntu-24.04
    if: always() && needs.generate-matrix.result == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install yq
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          command: |
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq

      - name: Create summary
        run: |
          HAS_BUILDS="${{ needs.generate-matrix.outputs.has_builds }}"

          if [ "$HAS_BUILDS" = "true" ]; then
            echo "## âœ… Registry published successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“¦ Registry URL" >> $GITHUB_STEP_SUMMARY
            echo "https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸš€ Quick Start" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "# Add the remote" >> $GITHUB_STEP_SUMMARY
            echo "incus remote add appliance https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }} --protocol simplestreams" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Launch an appliance" >> $GITHUB_STEP_SUMMARY
            echo "incus launch appliance:<name> my-instance" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“‹ Built Appliances" >> $GITHUB_STEP_SUMMARY
            for appliance in $(yq -r '.appliances[] | select(.enabled != false) | .name' appliances.yaml); do
              version=$(yq -r '.version // "0.0.0"' "appliances/${appliance}/appliance.yaml" 2>/dev/null || echo "0.0.0")
              archs=$(yq -r ".appliances[] | select(.name == \"${appliance}\") | .architectures // [\"amd64\", \"arm64\"] | join(\", \")" appliances.yaml)
              echo "- **${appliance}** v${version} (${archs})" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "## â„¹ï¸ No appliances needed rebuilding" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No appliance files were changed in this commit." >> $GITHUB_STEP_SUMMARY
          fi
